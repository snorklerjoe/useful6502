# Hardware Overview

This document provides an overview and detailed description of the hardware for this Useful 6502 Machine project.

## System Overview

The Useful 6502 Machine is a portable computer based on the WDC 65c02 CPU, featuring protected memory, a PIC16 peripheral coprocessor, dual-port SRAM, and support for external storage via SPI EEPROM and SD card. The system is designed for robust multitasking and expandability.

## Major Components

### 65c02 support logic

#### Clock and bus arbitration

The system clock is initially provided by an external function generator, allowing flexible frequency selection for bring-up and testing. The design includes provisions for a future custom clock board, perhaps with a clock divider to select multiple speeds.  
A hardware-test benchmark program will be used to determine maximum reliable clock speeds, which may be operation-dependent. However, the goal of this design is to clock the CPU at a frequency of at least 10MHz.

To meet the timing requirements of the 65c02 and its peripherals, the design generates several delayed and phase-shifted clock signals. Solder jumpers on the board allow for different devices to receieve clock signals with different delays imparted by slower 74xx logic series to ensure that setup and hold times can be met.  
The delayed clocks can also be used to operate bus switches as a measure against bus contention.

It is worth noting that the system clock as described here is separate from the PIC peripheral coprocessor (explained below), which will use an internal PLL or an external crystal. Rather, the system clock applies for the 65c02 CPU and any relevant synchronous devices thereattached.

#### User / Kernel mode logic

The design implements hardware-enforced user and kernel modes to provide memory protection and process isolation. This is achieved using glue logic that monitors the CPU's address and control lines.

When the CPU accesses an interrupt vector, the logic asserts a "kernel mode" signal. Access to kernel memory (the top 16k), as well as privileged instructions is gated by this signal. If user-mode code attempts to access protected resources, the hardware can trigger a fault. All faults are soft resets, which will not affect the information stored in memory but will lose information in the CPU registers. This is not an issue, as a process that generates a fault will be terminated by the kernel immediately and its memory freed.

#### Interrupts

Non-maskable interrupts will solely be generated by an externally-mapped timer in the 65c22 Versatle Interface Adapter (VIA) chip. This will be used to initiate forced context switching, interrupting whatever process is running regardless of the interrupt flag.
Normal (IRQ) interrupts will be used for i/o purposes, which can be disabled during timing-sensitive operations even while in userspace.

#### Direct character i/o

The primary user interface for this machine will be through a PS/2 keyboard input and a set of character LCD displays.

The PS/2 keyboard interface has a single byte buffer. Whenever a byte is received from the keyboard and the buffer is filled, the interface will signal to the keyboard that it cannot accept another byte by pulling the clock line low until the byte is read. The byte can be read by reading `PORTA` of the 65c22 VIA chip. The data ready / data taken handshake bits of the VIA are used by the PS/2 keyboard interface.

To output information to the character LCD interface, two bits of `PORTB` are used, via an active-low decoder, to select which LCD chip select line (of four) will be driven low. Two addional bits are used for the overall LCD enable, and the LCD register select.  
Writing to the data pins is functionally identical to writing to a memory banking regster (see below), with both least-significant address bits set. The LCD interface can only be written to, and so a character buffer will need to exist in memory.

### Memory

All volatile memory will be mapped into a bank-switched 65c02 address space. The mechanisms and specifics thereof are discussed below:

#### Memory map & address decode

Address decode is almost entirely performed by discrete 74xx logic gates. Devices are chosen carefully to consider propagation delays to attempt the maximum possible speed.

The overall virtual (or as far as the 65c02's address space is aware) memory map is as follows:

Addr Range  |   Label   |   Usage   |   Switched    |   User Privs
------------|-----------|-----------|---------------|----------------
FFFF<br>..<br>F810 | DMA  | Mapping of a dual-port SRAM shared with the PIC16 peripheral coprocessor | NEVER | None
F80F<br>..<br>F800 | VIA | Mapping of VIA hardware registers | NEVER | None
F7FF<br>..<br>C000 | KMEM | General-purpose resident kernel memory. Use for top-level trap routines, ISRs, context switching routines, and whatever else will fit. | NEVER | None
BFFF<br>..<br>8000 | BP2 | Third banked page. Available to user processes upon request. Mapped over the same physical memory as BP1 if not in use. | YES | RWX
7FFF<br>..<br>4000  | BP1 | Second banked page. Available to user processes upon request. Mapped over the same physical memory as BP1 if not in use. | YES | RWX
3FFF<br>..<br>0000 | BP0 | First banked page. Not to be confused with "Zero page", which is a portion of this region. Bank 0 belongs to kernel; everything else here is for userspace. | YES | RWX

All banked memory is physically stored on a daughterboard, for ease of experimentation and expandability.

As far as address decode is concerned, one subsection of the implementation determines a `HIMEM` condition based on the top two bits of the "virtual" address. Anything within "High-Memory" (the top 16kiB) belongs exclusively to the kernel. Obviously, the `VIA` and the `DMA` segments are not bank switched and exist physically within the corresponding devices. The `KMEM` segment is also a resident segment and is hardwired to be stored in bank zero.

#### Bank switching

There are a total of four banking registers in use, which technically enable up to 1 GiB of physical memory to be addressed. Because the memory needs to operate asynchronously and as a result of the cost of SRAM, it is unlikely this limit will ever be reached.
That being said, a PSRAM interface may be an option down the line, particularly as the CPU's bus synchronization controls are made available in the RAM daughterboard headers.

The banking registers are configured as follows:

The "Root bank" register (8-bits) is intended to select which RAM card is being addressed, and represents the 8 most-significant bits of the physical address.

The Bank [A, B, and C] registers store the next 8 most-significant bits. Which register is used for these bits is determined by the two most-significant bits of the virtual address, as defined in the memory map above.

Writing to these registers requires a few steps. Before writing to any of the bank registers, the `/WRITBANKEN` flag in `PORTB` of the 65c22 VIA must be driven low. At that point, the write may be performed (only by code executing in `HIMEM`) by any non-`HIMEM` write, partiularly a zero-page write. It is worth noting that the hardware stack will not function until the `/WRITBANKEN` flag is set back to a `1`. During the write, the "Root Bank" register is written if the third bit (bit 2) of the address is set. Otherwise, the A, B, or C register will be written according to the value of the two least-significant bits of the address. Thus, any bank switch may be performed with three 65c02 instructions: a PORTB clear-bit instruction, a zero-page write, and a set-bit instruction to reset `/WRITBANKEN`.

**Bank Register Map:**

Register      | Address/Selection Bits | Function
--------------|-----------------------|-----------
Root Bank    | Addr bit 2 = 1        | Selects RAM card (8 MSbs of physical addr)
Bank A       | Addr bits [1:0] = 00  | second 8 MSbs for BP0 region
Bank B       | Addr bits [1:0] = 01  | second 8 MSbs for BP1 region
Bank C       | Addr bits [1:0] = 10  | second 8 MSbs for BP2 region

Writes are enabled by clearing `/WRITBANKEN` (VIA PORTB), then writing to the appropriate address. The hardware stack is disabled during this operation and re-enabled by setting `/WRITBANKEN`.

**Note:** Registers are write-only; software should maintain shadow copies for context switching and debugging.

#### Memory protection

User memory will all be bank switched. Any process may be given 16, 32, or 48 kiB of memory in 1-3 banks, respectively. All bank registers will be context-switched, so that no process may access any memory outside of the banks assigned to it. If banks of virtual memory are unused by a process, they will be set to the same bank as `BP0`, so that the address space will wrap around.

While in user-mode, if the address becomes set to any location in `HIMEM` without first involving an interrupt vector-pull, a fault will occur and the process will be terminated as described above.

#### CY7C1041DV33 SRAM interface

The initial solution for volatile memory uses 4x CY7C1041DV33 (512kiB SRAM) to provide 2 MiB of RAM. The CY7C1041DV33 was chosen based on availability and price, despite it being arranged in 16-bit words and using 3.3V logic (requiring level conversion). Glue logic, buffers, and line drivers are thus used to interface to the RAM; see the schematic for more details.

#### Dual-port SRAM

The resident `DMA` segment of the address space is mapped to a CY7C146-25JC 2kiB dual-port SRAM, also chosen by availability and price.

This is accessed by both the 65c02 and the PIC peripheral coprocessor, described below. Mutual exclusion synchronization must be implemented in software to ensure that both processors do not attempt to access the same memory location, although there are hardware provisions for utilizing the CY7C146-25JC's built-in mutual-exclusion hardware to pause the 65c02 CPU in the event of an issue, though preferably the PIC will cooperatively yield.

### Peripheral Interfaces and I/O

#### PIC16 peripheral coprocessor

The PIC16 peripheral coprocessor is responsible for handling fast i/o, offloading time-sensitive and busywork-like i/o tasks from the 65c02. It communicates with the 65c02 primarily through the dual-port SRAM, allowing for efficient data exchange and command passing.

The PIC16 manages a few otherwse-tedious interfaces:

- **SD card interface** (via level-shifted open-collector SPI)  
    This will operate merely as a single-sector buffer and SPI interface. The actual FAT32 implementation will run on the 65c02. When it desires a sector be read, this can be signalled to the peripheral coprocessor via an interrupt, and the 65c02 can be interrupted later, once the entire sector is read into the `DMA` memory and ready for the FAT32 interface to access.
- **SPI EEPROM** (for bootloading and storage of the current kernel image)  
    The intention is that this can be written solely through the PIC over UART to flash a new kernel image and bootloader. The self-installing bootloader and boot-time interrupt vectors will be placed in DMA memory, and the 65c02 will be reset by the PIC. The two processors will then cooperate to move the kernel image from the EEPROM into memory in pieces that fit in the `DMA` memory. Once the image is loaded, a handshake will occur to ensure both processors are in a fully-initialized state before the 65c02 initializes drivers and starts up a shell.
- **General serial peripheral busses**, such as UART and I2C can be used to interface with other devices.  
    This may eventually include an ESP-01 based WiFi interface for network access, and will certainly enable the use of RS-232 peripherals down the line with an external MAX-232 based interface.

An ICSP header is included on the board to enable in-circuit programming and debugging of the PIC coprocessor.

Synchronization between the PIC16 and 65c02 is achieved through software protocols, with the option to use the dual-port SRAM's hardware mutual-exclusion features for critical sections as described previously, but the PIC16 is generally expected to yield access to shared resources as needed to avoid contention.

### Boot Process Summary

The boot process for this machine is as follows:

1. **Power-On:**
   - The PIC16 coprocessor initializes using its internal PLL or external crystal.
   - The 65c02 and peripherals are held in reset while the PIC performs initial checks.

2. **Firmware/Kernel Loading:**
   - The PIC16 bootloader communicates with a host PC (via UART) to receive a new kernel image if needed, programming it into the SPI EEPROM.
   - On normal boot, the PIC16 reads the kernel image from the SPI EEPROM and transfers it in chunks to the dual-port SRAM (DMA region) or main RAM.

3. **System Initialization:**
   - Once the kernel image is loaded, the PIC16 signals the 65c02 to release reset.
   - The 65c02 begins execution from the loaded kernel image, initializing memory, bank registers, and device drivers.

4. **Handshake and Ready State:**
   - The PIC16 and 65c02 perform a handshake via the dual-port SRAM to ensure both are ready.
   - The kernel may perform hardware tests or diagnostics before starting user processes.

5. **Normal Operation:**
   - The system enters normal operation, with the kernel on the 65c02 CPU managing multitasking, memory protection, and I/O.

This process ensures reliable startup, easy firmware updates, and robust initialization of all hardware subsystems.

---

*This document will be updated as features evolve.*
